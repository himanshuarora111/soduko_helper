<!DOCTYPE html>
<html>
<head>
<title>Advanced Sudoku Logical Solver - Color Coded</title>
<style>
    body { font-family: 'Segoe UI', sans-serif; text-align: center; background: #f4f6f8; }
    #status { font-weight: bold; margin-top: 10px; }
    #board { display: grid; grid-template-columns: repeat(9, 60px); grid-template-rows: repeat(9, 60px); margin: 20px auto; width: 540px; border: 2px solid black; }
    .cell { position: relative; border: 1px solid #999; transition: background 0.2s; background: white; }
    .big-input { width: 100%; height: 100%; font-size: 22px; text-align: center; border: none; outline: none; background: transparent; }
    .mini-grid { display: grid; grid-template-columns: repeat(3,1fr); grid-template-rows: repeat(3,1fr); width:100%; height:100%; font-size:11px; color:#777; cursor:pointer; }
    .mini-grid div { display:flex; align-items:center; justify-content:center; }
    .lock-badge { position:absolute; top:2px; right:4px; font-size:10px; font-weight:bold; color:#d35400; }
    .selected { outline:3px solid orange; z-index: 10; }
    
    /* BORDER LOGIC */
    .right-border { border-right:3px solid black; }
    .bottom-border { border-bottom:3px solid black; }
    .top-border { border-top:3px solid black; }
    .left-border { border-left:3px solid black; }

    /* COLOR SCHEME */
    .initial-input { color: black; font-weight: bold; }
    .auto-filled { color: green; font-weight: bold; }
    .manual-after-solve { color: blue; font-weight: bold; }

    button { padding:10px 18px; margin:5px; font-size:15px; border:none; border-radius:5px; cursor:pointer; background:#007bff; color:white; }
    button:hover { background:#0056b3; }
    .active-group { background:#8e44ad !important; }
    .active-lock { background:#e67e22 !important; }
</style>
</head>
<body>

<h2>Advanced Sudoku Logical Solver</h2>
<div id="status">Mode: Normal</div>

<button onclick="createBoard()">Reset Board</button>
<button onclick="solveSudoku()">Run Solver</button>
<button id="groupBtn" onclick="toggleGroupMode()">Group Mode</button>
<button onclick="confirmGroup()">Confirm Group</button>
<button id="lockBtn" onclick="toggleLockMode()">Digit Lock Mode</button>
<button onclick="confirmLock()">Confirm Digit Lock</button>
<button onclick="clearBoard()">Clear All</button>

<div id="board"></div>

<script>
let miniMode=false;
let groupMode=false;
let lockMode=false;
let solverHasRun=false; // Track if solver was triggered
let selectedCells=[];
let manualGroups=[];
let digitLocks=[];
let pastelColors=["#fde2e2","#e2f0fd","#e2fde9","#fff5d1","#f0e2fd","#e2fdf7","#ffe2f7","#eafde2"];
let colorIndex=0;

function updateStatus(){
    let status=document.getElementById("status");
    let groupBtn=document.getElementById("groupBtn");
    let lockBtn=document.getElementById("lockBtn");
    groupBtn.classList.remove("active-group");
    lockBtn.classList.remove("active-lock");
    if(groupMode){ status.innerText="Mode: Group Mode ACTIVE"; groupBtn.classList.add("active-group");
    }else if(lockMode){ status.innerText="Mode: Digit Lock Mode ACTIVE"; lockBtn.classList.add("active-lock");
    }else{ status.innerText="Mode: Normal"; }
}

function toggleGroupMode(){ groupMode=!groupMode; lockMode=false; selectedCells=[]; clearSelections(); updateStatus(); }
function toggleLockMode(){ lockMode=!lockMode; groupMode=false; selectedCells=[]; clearSelections(); updateStatus(); }
function clearSelections(){ document.querySelectorAll(".cell").forEach(c=>c.classList.remove("selected")); }

function createBoard(){
    const boardDiv = document.getElementById("board");
    boardDiv.innerHTML="";
    manualGroups=[]; digitLocks=[]; selectedCells=[]; colorIndex=0;
    miniMode=false; groupMode=false; lockMode=false; solverHasRun=false;
    updateStatus();

    for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
            let wrapper=document.createElement("div");
            wrapper.classList.add("cell");
            wrapper.dataset.row=r; wrapper.dataset.col=c;
            if(r%3===0) wrapper.classList.add("top-border");
            if(c%3===0) wrapper.classList.add("left-border");
            if((c+1)%3===0) wrapper.classList.add("right-border");
            if((r+1)%3===0) wrapper.classList.add("bottom-border");

            wrapper.addEventListener("click",()=>{
                if(groupMode||lockMode) toggleSelect(wrapper);
                else if(miniMode) switchToInput(wrapper);
            });
            createBigInput(wrapper,r,c);
            boardDiv.appendChild(wrapper);
        }
    }
}

function switchToInput(wrapper){
    let r=wrapper.dataset.row, c=wrapper.dataset.col;
    createBigInput(wrapper,r,c,"",false,true);
}

function toggleSelect(cell){
    let key=cell.dataset.row+"-"+cell.dataset.col;
    if(selectedCells.includes(key)){
        selectedCells=selectedCells.filter(x=>x!==key);
        cell.classList.remove("selected");
    }else{
        selectedCells.push(key);
        cell.classList.add("selected");
    }
}

function confirmGroup(){
    if(!groupMode || selectedCells.length < 2) return;
    let unit=getCommonUnit(selectedCells);
    if(!unit){ alert("Cells must share same row, column, or block."); return; }
    let digits=prompt("Enter digits (e.g., 17)");
    if(!digits) return;
    let arr=[...new Set(digits.split("").map(x=>parseInt(x)))];
    if(arr.length!==selectedCells.length){ alert("Digits count mismatch."); return; }
    
    let color=pastelColors[colorIndex%pastelColors.length];
    colorIndex++;
    manualGroups.push({ cells:[...selectedCells], digits:arr, unitType:unit.type, unitIndex:unit.index, color:color });
    selectedCells.forEach(k=>{
        let cell=getCellByKey(k);
        cell.style.background=color;
        cell.classList.remove("selected");
    });
    selectedCells=[];
    solveSudoku();
}

function confirmLock(){
    if(!lockMode || selectedCells.length < 2) return;
    let unit=getCommonUnit(selectedCells);
    if(!unit){ alert("Cells must share same row, column, or block."); return; }
    let digit=parseInt(prompt("Enter single digit (1-9)"));
    if(!digit || digit<1 || digit>9) return;

    digitLocks.push({ digit:digit, cells:[...selectedCells], unitType:unit.type, unitIndex:unit.index });
    selectedCells=[];
    clearSelections();
    solveSudoku();
}

function solveSudoku(){
    miniMode=true;
    let data=getBoardData(); // Returns { board, meta }
    let board = data.board;
    let meta = data.meta;
    let changed=true;
    
    while(changed){
        changed=false;
        for(let r=0;r<9;r++){
            for(let c=0;c<9;c++){
                if(board[r][c]===0){
                    let cand=getCandidates(board,r,c);
                    if(cand.length===1){ 
                        board[r][c]=cand[0]; 
                        meta[r][c]="auto"; // Mark as solved by logic
                        changed=true; 
                    }
                }
            }
        }
        for(let num=1; num<=9; num++){
            for(let i=0; i<9; i++){
                let rSpots=[], cSpots=[], bSpots=[];
                for(let j=0; j<9; j++){
                    if(board[i][j]===0 && getCandidates(board,i,j).includes(num)) rSpots.push(j);
                    if(board[j][i]===0 && getCandidates(board,j,i).includes(num)) cSpots.push(j);
                    let br=Math.floor(i/3)*3 + Math.floor(j/3), bc=(i%3)*3 + (j%3);
                    if(board[br][bc]===0 && getCandidates(board,br,bc).includes(num)) bSpots.push([br,bc]);
                }
                if(rSpots.length===1){ board[i][rSpots[0]]=num; meta[i][rSpots[0]]="auto"; changed=true; }
                if(cSpots.length===1){ board[cSpots[0]][i]=num; meta[cSpots[0]][i]="auto"; changed=true; }
                if(bSpots.length===1){ board[bSpots[0][0]][bSpots[0][1]]=num; meta[bSpots[0][0]][bSpots[0][1]]="auto"; changed=true; }
            }
        }
    }
    solverHasRun = true; 
    updateUI(board, meta);
}

function getCandidates(board,row,col){
    let list=[];
    for(let n=1;n<=9;n++) if(isValid(board,row,col,n)) list.push(n);
    let key=row+"-"+col;
    let currentBlock = Math.floor(row/3)*3 + Math.floor(col/3);

    manualGroups.forEach(g=>{
        if(g.cells.includes(key)){
            list=list.filter(x=>g.digits.includes(x));
        } else {
            let sameUnit = (g.unitType==="row" && row===g.unitIndex) || 
                           (g.unitType==="col" && col===g.unitIndex) || 
                           (g.unitType==="block" && currentBlock===g.unitIndex);
            
            let groupBlocks = [...new Set(g.cells.map(k => {
                let [r,c] = k.split("-").map(Number);
                return Math.floor(r/3)*3 + Math.floor(c/3);
            }))];
            let inGroupBlock = (groupBlocks.length === 1 && groupBlocks[0] === currentBlock);

            if(sameUnit || inGroupBlock) list=list.filter(x=>!g.digits.includes(x));
        }
    });

    digitLocks.forEach(l=>{
        let sameUnit = (l.unitType==="row" && row===l.unitIndex) || 
                       (l.unitType==="col" && col===l.unitIndex) || 
                       (l.unitType==="block" && currentBlock===l.unitIndex);

        let lockBlocks = [...new Set(l.cells.map(k => {
            let [r,c] = k.split("-").map(Number);
            return Math.floor(r/3)*3 + Math.floor(c/3);
        }))];
        let inLockBlock = (lockBlocks.length === 1 && lockBlocks[0] === currentBlock);

        if((sameUnit || inLockBlock) && !l.cells.includes(key)) list=list.filter(x=>x!==l.digit);
    });
    return list;
}

function updateUI(board, meta){
    document.querySelectorAll(".lock-badge").forEach(e=>e.remove());
    for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
            let cell=getCell(r,c);
            if(board[r][c]!==0) {
                createBigInput(cell,r,c,board[r][c], meta[r][c]);
            } else {
                createMiniGrid(cell,r,c);
            }
        }
    }
    digitLocks.forEach(l=>{
        l.cells.forEach(k=>{
            let cell=getCellByKey(k), badge=document.createElement("div");
            badge.classList.add("lock-badge"); badge.innerText="ðŸ”’"+l.digit;
            cell.appendChild(badge);
        });
    });
}

function getCommonUnit(cells){
    let rArr=cells.map(k=>parseInt(k.split("-")[0])), cArr=cells.map(k=>parseInt(k.split("-")[1]));
    let bArr=cells.map(k=>{ let [r,c]=k.split("-").map(Number); return Math.floor(r/3)*3+Math.floor(c/3); });
    if(rArr.every(x=>x===rArr[0])) return {type:"row",index:rArr[0]};
    if(cArr.every(x=>x===cArr[0])) return {type:"col",index:cArr[0]};
    if(bArr.every(x=>x===bArr[0])) return {type:"block",index:bArr[0]};
    return null;
}

// Track both value and who entered it
function getBoardData(){
    let board=Array.from({length:9},()=>Array(9).fill(0));
    let meta=Array.from({length:9},()=>Array(9).fill(null)); 
    document.querySelectorAll(".cell").forEach(cell=>{
        let input=cell.querySelector(".big-input");
        let r = cell.dataset.row, c = cell.dataset.col;
        if(input && input.value!=="") {
            board[r][c]=parseInt(input.value);
            // Detect if this was initial, blue, or auto
            if(input.classList.contains("initial-input")) meta[r][c] = "initial";
            else if(input.classList.contains("manual-after-solve")) meta[r][c] = "manual";
            else if(input.classList.contains("auto-filled")) meta[r][c] = "auto";
            else meta[r][c] = "initial"; // Default for first run
        }
    });
    return {board, meta};
}

function isValid(board,row,col,num){
    for(let i=0;i<9;i++){
        if(i!==col && board[row][i]===num) return false;
        if(i!==row && board[i][col]===num) return false;
    }
    let sr=Math.floor(row/3)*3, sc=Math.floor(col/3)*3;
    for(let r=sr;r<sr+3;r++) for(let c=sc;c<sc+3;c++)
        if((r!==row||c!==col)&&board[r][c]===num) return false;
    return true;
}

function createBigInput(wrapper,r,c,value="", type="initial"){
    wrapper.innerHTML="";
    let input=document.createElement("input");
    input.classList.add("big-input"); input.maxLength=1; input.value=value;
    
    // Apply appropriate class
    if(type === "auto") input.classList.add("auto-filled");
    else if(type === "manual") input.classList.add("manual-after-solve");
    else input.classList.add("initial-input");

    input.addEventListener("input", () => { 
        if(input.value && !/[1-9]/.test(input.value)) {
            input.value = "";
        } else if(input.value !== "") {
            // New entry logic: if solver has run, make it blue. Otherwise black.
            input.className = "big-input"; 
            input.classList.add(solverHasRun ? "manual-after-solve" : "initial-input");
        }
    });

    input.addEventListener("blur",()=>{ if(input.value==="") createMiniGrid(wrapper,r,c); });
    wrapper.appendChild(input);
}

function createMiniGrid(wrapper,r,c){
    wrapper.innerHTML="";
    let mini=document.createElement("div");
    mini.classList.add("mini-grid");
    let data=getBoardData(), cand=getCandidates(data.board,r,c);
    for(let i=1;i<=9;i++){
        let d=document.createElement("div");
        if(cand.includes(i)) d.textContent=i;
        mini.appendChild(d);
    }
    wrapper.appendChild(mini);
}

function getCell(r,c){ return document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`); }
function getCellByKey(key){ let [r,c]=key.split("-"); return getCell(r,c); }
function clearBoard(){ createBoard(); }

createBoard();
</script>
</body>
</html>
